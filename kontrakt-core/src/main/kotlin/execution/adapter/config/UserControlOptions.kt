package execution.adapter.config

import reporting.adapter.config.ReportFormat

/**
 * [ADR-016] User Control Surface
 *
 * An immutable configuration object representing the aggregation of all user-supplied
 * execution and reporting control options. This object acts as the **Single Source of Truth**
 * within the execution context, decoupling the core engine from CLI parsers or configuration files.
 *
 * Design Principles:
 * - **Immutability:** Ensures thread-safe configuration propagation.
 * - **Defaults:** Provides a "Safe & Informative" baseline configuration (Tier 1).
 * - **ADR Compliance:** Directly implements strategies defined in ADR-015, 016, and 024.
 */
data class UserControlOptions(
    // --- Observability & Audit Configuration ---

    /**
     * [--trace]
     * Flag to enable **Synthetic BDD Audit** mode.
     * If true, detailed events for Design, Execution, and Verification phases will be collected.
     * This incurs a slight performance penalty but provides full transparency into the framework's decision-making.
     */
    val traceMode: Boolean = false,

    /**
     * [--verbose / --quiet]
     * Controls the verbosity level of the console output.
     * Determines the granularity of the operational logs presented to the user.
     */
    val verbosity: Verbosity = Verbosity.NORMAL,

    /**
     * [--stacktrace-limit 15]
     * Limits the number of stack frames reported in exceptions to reduce noise in the console output.
     * Set to -1 for unlimited stack traces.
     */
    val stackTraceLimit: Int = 15,

    // --- Targeting & Scope Configuration ---

    /**
     * [--tests "pattern"]
     * Filter patterns to execute only specific classes or methods.
     * Supports wildcards (e.g., "com.shop.*Order*", "MyTest").
     * If empty, a full scan is performed.
     */
    val testPatterns: Set<String> = emptySet(),

    /**
     * [--package "name"]
     * Limits the scanning scope to a specific package (and sub-packages) to support fast feedback loops.
     * If null, scanning starts from the root classpath.
     */
    val packageScope: String? = null,

    // --- Reporting & Artifact Management ([ADR-015]) ---

    /**
     * [--archive]
     * [ADR-015] Report retention policy.
     * If true, the report is saved as a timestamped file (e.g., `history/report-{time}.html`) to prevent data loss.
     * If false, the standard `index.html` is overwritten (Default behavior for local dev).
     */
    val archiveMode: Boolean = false,

    /**
     * [ADR-015] Enabled Reporting Formats.
     * Explicitly controls which output artifacts are generated by the engine.
     *
     * **Default Strategy:**
     * Defaults to [ReportFormat.CONSOLE], [ReportFormat.HTML], and [ReportFormat.JSON].
     * This adheres to the "Evidence is always present" philosophy, ensuring developers
     * have access to Deep Analysis Tools (HTML) without needing to re-run tests after a failure.
     */
    val reportFormats: Set<ReportFormat> = setOf(
        ReportFormat.CONSOLE,
        ReportFormat.HTML,
        ReportFormat.JSON
    ),

    // --- Reproduction & Reliability ([ADR-024]) ---

    /**
     * [--seed 12345]
     * Fixes the random seed for **Deterministic Reproduction** of property-based tests.
     * If null, a new secure random seed is generated for each run.
     */
    val seed: Long? = null,

    ) {
    /**
     * Defines the level of detail for console output.
     */
    enum class Verbosity {
        QUIET, // Outputs only critical failure summaries.
        NORMAL, // Outputs smart summaries and failure details (Default).
        VERBOSE, // Outputs full details including successful logs and internal events.
    }

    /** Helper to check if full logging is enabled. */
    val isVerbose: Boolean
        get() = verbosity == Verbosity.VERBOSE

    companion object {
        /**
         * Represents the default configuration baseline.
         * Corresponds to a standard local development environment (Tier 1).
         */
        val DEFAULT = UserControlOptions()

        fun fromSystemProperties(): UserControlOptions {
            return UserControlOptions(
                traceMode = System.getProperty("kontrakt.trace")?.toBoolean() ?: false,
                reportFormats = parseReportFormats(),
                archiveMode = System.getProperty("kontrakt.archive")?.toBoolean() ?: false,
                seed = System.getProperty("kontrakt.seed")?.toLongOrNull()
                // ... map other fields (verbosity, patterns, etc.)
            )
        }

        private fun parseReportFormats(): Set<ReportFormat> {
            val formats = mutableSetOf<ReportFormat>()
            // [ADR-015] User Defaults (Opt-out strategy)
            if (System.getProperty("kontrakt.reports.html") != "false") formats.add(ReportFormat.HTML)
            if (System.getProperty("kontrakt.reports.json") != "false") formats.add(ReportFormat.JSON)
            // Console is usually implicitly handled, but can be explicitly added
            if (System.getProperty("kontrakt.reports.console") != "false") formats.add(ReportFormat.CONSOLE)
            return formats
        }
    }
}